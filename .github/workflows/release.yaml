name: EZ-Clean-Android10-CGO-Test

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  # 允许在 GitHub Actions 页面手动触发此工作流
  workflow_dispatch:

env:
  GO_VERSION: '1.21'
  MODULE_NAME: 'EZ-Clean'
  # 使用较新的稳定版 NDK 以获得更好的工具链支持
  NDK_VERSION: 'r26d'

jobs:
  # 构建核心任务，使用矩阵策略并行构建所有架构和变体
  build-multi-arch:
    runs-on: ubuntu-latest
    strategy:
      # 构建矩阵定义了所有需要编译的架构和变体组合
      # 这将产生 2 个变体 * 4 个架构 = 8 个并行的构建任务
      matrix:
        include:
          - goarch: arm64
            android_abi: arm64-v8a
            toolchain_triple: aarch64-linux-android29
          - goarch: arm
            android_abi: armeabi-v7a
            toolchain_triple: armv7a-linux-androideabi29
          - goarch: amd64
            android_abi: x86_64
            toolchain_triple: x86_64-linux-android29
          - goarch: 386
            android_abi: x86
            toolchain_triple: i686-linux-android29
        variant: [basic, full]
      # fail-fast: false 确保即使矩阵中有一个任务失败，其他任务也会继续运行
      fail-fast: false

    name: Build ${{ matrix.variant }} for ${{ matrix.android_abi }}

    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 设置 Go 环境
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
          cache-dependency-path: go.sum

      - name: 设置安卓 NDK
        uses: nttld/setup-ndk@v1
        id: setup-ndk
        with:
          ndk-version: ${{ env.NDK_VERSION }}

      - name: 安装构建依赖
        run: |
          # 确保脚本在任何命令失败时立即退出
          set -e
          sudo apt-get update
          sudo apt-get install -y zip file

      - name: 初始化 Go 模块
        run: |
          set -e
          # 如果 go.mod 不存在，则初始化
          if [ ! -f "go.mod" ]; then
            # 使用正确的仓库路径来初始化 go mod
            go mod init github.com/${{ github.repository }}
          fi
          go mod tidy

      - name: 定位 Go 源文件
        id: source_files
        run: |
          set -e
          if [ -f "source/main.go" ]; then
            echo "MAIN_GO=source/main.go" >> "$GITHUB_OUTPUT"
            echo "EZ_GO=source/ez.go" >> "$GITHUB_OUTPUT"
          elif [ -f "main.go" ]; then
            echo "MAIN_GO=main.go" >> "$GITHUB_OUTPUT"
            echo "EZ_GO=ez.go" >> "$GITHUB_OUTPUT"
          else
            echo "错误：未找到 Go 源文件。"
            exit 1
          fi

      - name: 设置构建参数
        id: build_params
        run: |
          echo "ZIP_NAME=EZ-Clean-${{ matrix.variant }}-${{ matrix.android_abi }}.zip" >> "$GITHUB_OUTPUT"
          echo "MODULE_DIR=module-${{ matrix.variant }}-${{ matrix.android_abi }}" >> "$GITHUB_OUTPUT"

      - name: 验证 NDK 交叉编译器是否存在
        # 简化路径查找，使用 NDK_HOME 环境变量
        run: |
          set -e
          NDK_PATH=${{ steps.setup-ndk.outputs.NDK_PATH }}
          COMPILER_PATH="$NDK_PATH/toolchains/llvm/prebuilt/linux-x86_64/bin/${{ matrix.toolchain_triple }}-clang"
          echo "正在检查编译器: $COMPILER_PATH"
          if [ ! -f "$COMPILER_PATH" ]; then
            echo "❌ 编译器未在预期路径找到！"
            find "$NDK_PATH/toolchains/llvm/prebuilt/linux-x86_64/bin/" -name "*clang*"
            exit 1
          fi
          echo "✅ 编译器已找到。版本信息:"
          "$COMPILER_PATH" --version

      - name: 使用 CGO 交叉编译安卓二进制文件
        env:
          GOOS: android
          GOARCH: ${{ matrix.goarch }}
          CGO_ENABLED: 1
          # 使用步骤输出的 NDK 路径设置 CC 变量
          CC: ${{ steps.setup-ndk.outputs.NDK_PATH }}/toolchains/llvm/prebuilt/linux-x86_64/bin/${{ matrix.toolchain_triple }}-clang
        run: |
          set -e
          BINARY_NAME="EZ-${{ matrix.variant }}-${{ matrix.android_abi }}"
          # 修正变量引用，使用 $() 或双引号
          if [ "${{ matrix.variant }}" = "basic" ]; then
            SOURCE_FILE="${{ steps.source_files.outputs.MAIN_GO }}"
          else
            SOURCE_FILE="${{ steps.source_files.outputs.EZ_GO }}"
          fi
          
          echo "正在编译源文件: $SOURCE_FILE"
          # 使用 -trimpath 确保可重现性
          go build -trimpath -ldflags="-s -w" -o "$BINARY_NAME" "$SOURCE_FILE"
          
          echo "✅ 编译成功。二进制文件信息:"
          file "$BINARY_NAME"
          ls -lh "$BINARY_NAME"

      - name: 更新模块属性文件 (module.prop)
        run: |
          set -e
          # 修复：确保在写入文件时，使用 `cat > ... << EOF` 的方式不会引入额外的缩进
          
          # 备份原始文件
          if [ -f "module.prop" ]; then
            cp module.prop module.prop.backup
          fi
          
          VERSION_DATE=$(date +%Y.%m.%d)
          VERSION_CODE=$(( $(date +%s) / 100 ))
          
          # 注意：这里的 EOF 必须顶格写，否则 shell 会将缩进也写入文件
          cat > module.prop << EOF
id=${{ env.MODULE_NAME }}
name=${{ env.MODULE_NAME }}
version=v${VERSION_DATE}
versionCode=${VERSION_CODE}
author=GitHub Actions
description=为 ${{ matrix.android_abi }} 构建的多架构模块（${{ matrix.variant }} 版）。
architecture=${{ matrix.android_abi }}
EOF

      - name: 准备模块文件
        run: |
          set -e
          BINARY_NAME="EZ-${{ matrix.variant }}-${{ matrix.android_abi }}"
          MODULE_DIR="${{ steps.build_params.outputs.MODULE_DIR }}"
          mkdir -p "$MODULE_DIR"
          
          # 复制通用模块文件（如果存在）
          # 使用 -L 选项处理符号链接
          [ -d "META-INF" ] && cp -rL META-INF/ "$MODULE_DIR"/
          [ -f "customize.sh" ] && cp customize.sh "$MODULE_DIR"/
          [ -f "service.sh" ] && cp service.sh "$MODULE_DIR"/
          
          # 复制生成的 module.prop 和编译好的二进制文件
          cp module.prop "$MODULE_DIR"/
          # Magisk 模块通常要求二进制文件名为模块 ID，这里假设模块 ID 为 EZ
          cp "$BINARY_NAME" "$MODULE_DIR"/EZ 
          chmod +x "$MODULE_DIR"/EZ
          
          echo "模块文件已准备就绪于 $MODULE_DIR/:"
          ls -la "$MODULE_DIR"/

      - name: 打包模块为 Zip 文件
        run: |
          set -e
          cd ${{ steps.build_params.outputs.MODULE_DIR }}
          # 使用相对路径打包，确保 Zip 文件内没有顶层目录
          zip -r ../${{ steps.build_params.outputs.ZIP_NAME }} .
          cd ..
          echo "打包完成: ${{ steps.build_params.outputs.ZIP_NAME }}"

      - name: 恢复原始 module.prop
        if: always() # 无论成功或失败都执行此步骤
        run: |
          if [ -f "module.prop.backup" ]; then
            mv module.prop.backup module.prop
            echo "原始 module.prop 已恢复。"
          fi

      - name: 上传模块构建产物
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.build_params.outputs.ZIP_NAME }}
          path: ${{ steps.build_params.outputs.ZIP_NAME }}
          retention-days: 7

  # 构建汇总任务，作为创建 Release 之前的“守门员”
  build-summary:
    name: 构建结果汇总
    runs-on: ubuntu-latest
    needs: build-multi-arch # 依赖于所有构建任务
    if: always() # 即使有构建失败也运行，以便提供汇总报告
    # 修正：将 output 定义移到 jobs 级别
    outputs:
      build_succeeded: ${{ steps.summary.outputs.build_succeeded }}
      
    steps:
      - name: 下载所有构建产物
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          
      - name: 显示构建汇总报告
        id: summary
        run: |
          set -e
          echo "=== 构建汇总报告 ==="
          TOTAL_EXPECTED=8
          TOTAL_BUILT=$(find artifacts -type f -name "*.zip" | wc -l)
          
          echo "已完成的构建:"
          find artifacts -type f -name "*.zip" -printf "✅ %f\n"

          echo "====================="
          echo "总计构建: $TOTAL_BUILT/$TOTAL_EXPECTED"
          
          if [ $TOTAL_BUILT -ne $TOTAL_EXPECTED ]; then
            # 修复：使用双引号将变量值包装起来，防止特殊字符干扰
            echo "build_succeeded=false" >> "$GITHUB_OUTPUT"
            echo "⚠️ 部分构建失败。已中止发布流程。"
            # 注意：此处不应使用 exit 1，否则 if: always() 的任务也会被标记为失败，影响后续判断
          else
            echo "build_succeeded=true" >> "$GITHUB_OUTPUT"
            echo "🎉 所有构建均已成功！正在准备发布..."
          fi

  # 创建 GitHub Release 任务
  create-release:
    runs-on: ubuntu-latest
    needs: build-summary # 依赖于汇总任务
    # 修正：条件判断必须使用 `fromJson` 或确保输出是纯布尔/字符串
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.build-summary.outputs.build_succeeded == 'true'
    permissions:
      contents: write # 需要此权限来创建 Release 并上传产物
      
    steps:
      - name: 下载所有构建产物
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: 准备发布所需的文件 (Release Assets)
        id: release_assets
        # 修复：这里的 run 块使用了多行 shell 脚本，需要注意 Shell 变量的转义和引号
        run: |
          set -e
          # 将所有 zip 文件从子目录移动到顶层 artifacts 目录
          find artifacts -type f -name "*.zip" -exec mv {} artifacts/ \;

          TAG_NAME="android10-$(date +'%Y.%m.%d-%H%M')"
          RELEASE_NAME="${{ env.MODULE_NAME }} 安卓 10+ | $(date +'%Y.%m.%d')"
          VERSION_CODE=$(( $(date +%s) / 100 ))

          echo "TAG_NAME=${TAG_NAME}" >> "$GITHUB_OUTPUT"
          echo "RELEASE_NAME=${RELEASE_NAME}" >> "$GITHUB_OUTPUT"
          
          # 为每个架构生成 update.json 文件
          for zip_file in artifacts/*.zip; do
            BASENAME=$(basename "$zip_file" .zip)
            # 使用更健壮的 sed 命令来提取 ABI
            ABI=$(echo "$BASENAME" | grep -oE '(arm64-v8a|armeabi-v7a|x86_64|x86)$')
            JSON_FILE="artifacts/update-${ABI}.json"
            
            # 使用 EOF 确保 JSON 格式正确，且变量被正确展开
            cat > "$JSON_FILE" << EOF
{
  "version": "v$(date +%Y.%m.%d)",
  "versionCode": ${VERSION_CODE},
  "zipUrl": "https://github.com/${{ github.repository }}/releases/download/${TAG_NAME}/$(basename "$zip_file")",
  "changelog": "https://github.com/${{ github.repository }}/releases/tag/${TAG_NAME}"
}
EOF
          done

          # 生成发布日志 (Release Notes)
          NOTES_FILE="artifacts/RELEASE_NOTES.md"
          # 使用重定向块来生成 Markdown 文件
          {
            echo "# ${{ env.MODULE_NAME }} 多架构发布版"
            echo "**构建时间**: $(date +'%Y-%m-%d %H:%M:%S UTC')"
            echo "**代码提交**: \`${{ github.sha }}\`"
            echo ""
            echo "此版本为所有主流安卓 CPU 架构提供了构建。请安装与您设备架构相匹配的模块。"
            echo ""
            echo "### 安装指南"
            echo "1. 使用类似 CPU-Z 的应用检查您设备的 ABI（架构）。"
            echo "2. 从下方的附件中下载匹配的 Zip 文件。"
            echo "3. 通过 Magisk 或 KernelSU 刷入模块并重启。"
            echo ""
            echo "### 文件列表"
            echo ""
            echo "#### 基础版 (核心功能)"
            echo "| 架构 | 大小 |"
            echo "| :--- | :--- |"
            # 遍历并输出基础版信息
            find artifacts -name "EZ-Clean-basic-*.zip" -print0 | sort -z | while IFS= read -r -d '' file; do
                SIZE=$(du -h "$file" | cut -f1); ARCH=$(basename "$file" .zip | grep -oE '(arm64-v8a|armeabi-v7a|x86_64|x86)$')
                echo "| \`$ARCH\` | \`$SIZE\` |"
            done
            echo ""
            echo "#### 完整版 (扩展功能)"
            echo "| 架构 | 大小 |"
            echo "| :--- | :--- |"
            # 遍历并输出完整版信息
            find artifacts -name "EZ-Clean-full-*.zip" -print0 | sort -z | while IFS= read -r -d '' file; do
                SIZE=$(du -h "$file" | cut -f1); ARCH=$(basename "$file" .zip | grep -oE '(arm64-v8a|armeabi-v7a|x86_64|x86)$')
                echo "| \`$ARCH\` | \`$SIZE\` |"
            done
          } > "$NOTES_FILE"

      - name: 创建 GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.release_assets.outputs.TAG_NAME }}
          name: ${{ steps.release_assets.outputs.RELEASE_NAME }}
          body_path: artifacts/RELEASE_NOTES.md
          # 上传 artifacts 目录下所有文件，包括 Zip 和 update.json
          files: artifacts/*

  # 清理旧的工作流运行记录
  workflow-cleanup:
    runs-on: ubuntu-latest
    needs: create-release
    # 修正：即使 release 失败，也应尝试清理
    if: always() && github.ref == 'refs/heads/main'
    permissions:
      actions: write # 此权限是删除工作流运行记录所必需的
      
    steps:
      - name: 清理旧的工作流运行记录
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.repository }}
          retain_days: 0
          keep_minimum_runs: 0
